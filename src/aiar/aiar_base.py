import argparse
from functools import lru_cache
import os
import sys
from typing import Generator
import uuid
from pathlib import Path

# The 'pathspec' library is the standard for parsing .gitignore files.
# This script will check if it's installed and provide instructions if not.
try:
    import pathspec
except ImportError:
    print(
        "Warning: 'pathspec' library not found. .gitignore parsing will be skipped.",
        file=sys.stderr,
    )
    print("         Install it with: pip install pathspec", file=sys.stderr)
    pathspec = None

# This is the static bash script that will unpack the archive.
# The unique separator is injected into it when the script is generated.
AIAR_HEADER = """#!/bin/bash
# aiar: AI Archive - Self-extracting script generated by aiar-py.

writing=false
SEPARATOR="{separator}"

# Function to report errors and exit
handle_error() {{
  echo "Error: $1" >&2
  exit 1
}}

while IFS= read -r line; do
  # Use parameter expansion for speed and robustness.
  if [[ "$line" == "$SEPARATOR"* ]]; then
    if [ "$writing" = true ]; then
      exec 3>&-
      writing=false
    fi

    filepath="${{line#$SEPARATOR}}"
    if [ -n "$filepath" ]; then
      mkdir -p "$(dirname "$filepath")" || handle_error "Cannot create directory for '$filepath'. Check permissions."
      exec 3>"$filepath" || handle_error "Cannot open '$filepath' for writing. Check permissions."
      echo "Creating: $filepath"
      writing=true
    fi
  elif [ "$writing" = true ]; then
    echo "$line" >&3
  fi
done < "$0"

if [ "$writing" = true ]; then
  exec 3>&-
fi

echo "Extraction complete."
exit 0

# --- DATA PAYLOAD ---
"""


def find_git_root(start_path):
    """Find the root of the git repository."""
    p = Path(start_path).resolve()
    while p != p.parent:
        if (p / ".git").exists():
            return p
        p = p.parent
    return None


@lru_cache(maxsize=128)
def get_gitignore_spec(start_path, use_gitignore) -> pathspec.PathSpec | None:
    """Loads .gitignore rules from the repository root."""
    if not use_gitignore or not pathspec:
        return None

    git_root = find_git_root(start_path)
    if not git_root:
        return None

    gitignore_path = git_root / ".gitignore"
    if gitignore_path.is_file():
        with open(gitignore_path, "r") as f:
            return pathspec.PathSpec.from_lines("gitwildmatch", f)
    return None


def find_files_to_archive(paths, spec, base_dir) -> Generator[Path, None, None]:
    """Walks through input paths and yields files that are not ignored.

    - Always passes POSIX-style relative paths to the ignore matcher
    - Prunes ignored directories (e.g., "node_modules/") during traversal
    """
    for path_arg in paths:
        path_obj = Path(path_arg).resolve()
        if path_obj.is_file():
            rel = path_obj.relative_to(base_dir).as_posix()
            if spec and spec.match_file(rel):
                continue
            yield path_obj
            continue

        for root, dirnames, files in os.walk(path_obj):
            root_path = Path(root)

            # Prune ignored directories so we don't descend into them
            if spec and dirnames:
                kept = []
                for d in dirnames:
                    rel_dir = (root_path / d).relative_to(base_dir).as_posix()
                    # Check both with and without trailing slash for directory patterns
                    # .gitignore patterns like "__pycache__/" and "node_modules/" should match
                    if spec.match_file(rel_dir) or spec.match_file(rel_dir + "/"):
                        continue
                    kept.append(d)
                # Modify dirnames in-place for os.walk to respect pruning
                dirnames[:] = kept

            for filename in files:
                full_path = root_path / filename
                rel_file = full_path.relative_to(base_dir).as_posix()

                if spec and spec.match_file(rel_file):
                    continue

                yield full_path


def create_aiar(output_file, files_to_archive, base_dir):
    """Generates the aiar script by writing the header and file data."""
    # Generate a unique separator to prevent collisions with file content.
    separator = f"++++++++++--------:{uuid.uuid4()}:"

    # Write the header, injecting the unique separator.
    output_file.write(AIAR_HEADER.format(separator=separator))

    sorted_files = sorted(list(files_to_archive))

    for filepath in sorted_files:
        try:
            # Create a relative path for the archive to preserve structure.
            relative_path = filepath.relative_to(base_dir).as_posix()

            # Write the separator line followed by the file content.
            output_file.write(f"{separator}{relative_path}\n")
            with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
                output_file.write(f.read())
            # Ensure the file data ends with a newline for the read loop.
            output_file.write("\n")
        except Exception as e:
            print(
                f"Warning: Could not read file '{filepath}'. Skipping. Error: {e}",
                file=sys.stderr,
            )


def _main():
    parser = argparse.ArgumentParser(
        description="Generate an aiar (AI Archive) self-extracting shell script.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "paths", nargs="+", help="One or more files or directories to archive."
    )
    parser.add_argument(
        "-o",
        "--output",
        help="Output file for the aiar script. Defaults to stdout.",
    )
    parser.add_argument(
        "--no-gitignore",
        action="store_true",
        help="Disable using .gitignore files for exclusion.",
    )

    args = parser.parse_args()
    
    resolved_paths = [Path(p).resolve() for p in args.paths]
    base_dir = Path(os.path.commonpath(resolved_paths))
    if base_dir.is_file():
        base_dir = base_dir.parent

    spec = get_gitignore_spec(base_dir, not args.no_gitignore)
    files_to_process = find_files_to_archive(resolved_paths, spec, base_dir)

    # Use a set to handle potential duplicates if paths overlap
    unique_files = set(files_to_process)

    if not unique_files:
        print("No files found to archive.", file=sys.stderr)
        return

    if args.output:
        with open(args.output, "w", encoding="utf-8") as f:
            create_aiar(f, unique_files, base_dir)
        print(f"aiar script created at '{args.output}'")
        os.chmod(args.output, 0o755) # Make it executable
    else:
        create_aiar(sys.stdout, unique_files, base_dir)


if __name__ == "__main__":
    import sys
    sys.argv = [
        sys.argv[0],
        "grip-react",
        "-o",
        "grip-react.aiar",
    ]
    _main()
